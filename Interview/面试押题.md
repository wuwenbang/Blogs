# HTML

## 1 HTML 语义化

- 概念：语义化标签是一种写 HTML 标签的方法论。
- 优点：1.适合搜索引擎。2.适合人类阅读，利于团队维护

## 2 HTML 新标签

- 文章相关：header main footer main article
- 多媒体相关： video audio svg canvas

# CSS

## 1 BFC

- 概念：块级格式化上下文
- 描述：具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。
- 触发条件：
  - 浮动元素 float
  - 绝对定位元素 position absolute fixed
  - 行内块元素 inline block
  - overflow != visible 的块元素
  - 弹性元素 flex
- 解决问题：
  - 清除浮动
  - 防止 margin 合并
  - 可以阻止元素被浮动元素覆盖

## 2 垂直居中

1. 设置行高 line-height 等于 height（适用于 inline inline-block 元素）
2. calc 动态计算（top: calc(50% - height/2) ）
3. 使用表格或者假装表格

```css
width: 150px;
height: 100px;
border: 1px solid #000;
display: table-cell;
vertical-align: middle;
```

4. transform

```css
position: relative;
top: 50%;
transform: translateY(-50%);
```

5. 绝对定位

```css
position: absolute;
top: 0;
right: 0;
bottom: 0;
left: 0;
margin: auto;
```

6. Flexbox

## 3 CSS 选择器优先级如何确定？

1. 选择器越具体，优先级越高。
2. 相同优先级，出现在后面的，覆盖前面的。
3. 属性后面加 !important 的优先级最高，但是要少用。

## 4 如何清除浮动

1. 给父元素添加 `.clearfix`

```css
.clearfix:after {
  content: '';
  display: block;
  clear: both;
}
```

2. 给父元素添加 `overflow:hidden;`

## 5 盒模型

1. border-box
   实际宽度 = width
2. content-box
   实际宽度 = width + padding + border

# JavaScript

## 1 JavaScript 数据类型

- number
- string
- boolean
- undefined
- null
- object
- symbol
- bigint

## 2 JavaScript 原型链

- `obj.__proto__ = Object.prototype`
- 更改原型
  1.  Object.create(f)
  2.  new f()
- 解决问题：在没有 class 的情况下实现继承
- 缺点：与 class 相比不支持私有熟悉

## 3 this 是什么？

- 概念：this 是 call 的第一个参数。（谁调用了 this ，this 就是什么）
  - `f1() == f1.call(undefined, 'hi')`
  - `a.b.f('hi') == f.call(a.b, 'hi')`

## 4 new 做了什么？

1. 创建临时对象
2. 绑定原型
3. 指定 this = 临时对象
4. 执行构筑函数
5. 返回临时对象

## 5 立即执行函数是什么？

- 概念：声明一个函数立即执行
- 作用：创建一个局部变量（ES5）

```js
!(function () {
  console.log('hello');
})();
```

## 6 闭包是什么？

- 概念：闭包是 JS 的一种语法特性。
- 公式：闭包 = 函数 + 自由变量（非全局变量和局部变量）
- 解决问题：
  - 避免污染全局环境
  - 提供对局部变量的间接访问
  - 防止变量被垃圾回收

## 7 实现一个类

prototype 实现

```js
function Dog(name) {
  this.name = name;
}
Dog.prototype.say = function () {
  console.log(`hello my name is ${this.name}`);
};
```

class 实现

```js
class Dog {
  constructor(name) {
    this.name = name;
  }
  say() {
    console.log(`hello my name is ${this.name}`);
  }
}
```

## 8 实现继承

ES5

```js
function Animal(legs) {
  this.legs = legs;
}
Animal.prototype.kind = 'animal';

function Dog(name) {
  Animal.call(this, 4);
  this.name = name;
}
Dog.prototype.__protp__ = Animal.prototype; // ban

var f = function () {};
f.prototype = Animal.prototype;
Dog.prototype = new f();
```

ES6

```js
class Animal {
  constructor(legs) {
    this.legs = legs;
  }
  run() {}
}
class Dog extends Animal {
  constructor(name) {
    super(4);
    this.name = name;
  }
  say() {}
}
```

## 函数节流和防抖

```js
// 函数节流
function throttle(fn, wait) {
  let timer = null;
  return (...args) => {
    // 冷却中返回
    if (timer) return;
    // 执行函数
    fn(...args);
    // 设置冷却时间
    timer = setTimeout(() => {
      timer = null;
    }, wait);
  };
}
```

```js
// 函数防抖
function debounce(fn, wait) {
  let timer = null;
  return (...args) => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => fn(...args), wait);
  };
}
```

## 发布订阅

```js
// 发布订阅
const eventHub = {
  map: {},
  on(name, fn) {
    // 入队
    eventHub.map[name] = eventHub.map[name] || [];
    eventHub.map[name].push(fn);
  },
  off(name, fn) {
    const list = eventHub.map[name];
    if (!list) return;
    const index = list.indexOf(fn);
    if (index < 0) return;
    list.splice(index, 1);
  },
  emit(name, data) {
    const list = eventHub.map[name];
    if (!list) return;
    list.map(f => f(data));
  },
};
const fn = () => console.log('hello');
eventHub.on('click', fn);
eventHub.emit('click');
eventHub.off('click', fn);
eventHub.emit('click');
```

## 手写 AJAX

```js
var request = new XMLHttpRequest();

request.open('GET', '/xxx');
request.onreadystatechange = () => {
  if (request.readyState === 4) {
    if (
      (request.status >= 200 && request.status < 300) ||
      request.status === 304
    ) {
      success();
    } else {
      failed();
    }
  }
};
request.onerror = () => {
  console.log('error');
};
request.send('{"name":"frank"}');
```

## 数组去重

```js
// 数组去重
function unique(list) {
  const result = [];
  for (let item of list) {
    if (result.indexOf(item) === -1) {
      result.push(item);
    }
  }
  return result;
}
```

## DOM 事件模型

- 先经历从上到下的捕获阶段，再经历从下到上的冒泡阶段。
- `addEventListener('click',fn,true/false)` 第三个参数选择阶段（true 为捕获，默认为冒泡）。
- 可以使用 `event.stopPropagation()` 来阻止捕获或冒泡。

## DOM 事件委托

- `e.currentTarget` 事件绑定的对象
- `e.current` 事件触发的对象

```js
function on(element, eventType, selector, fn) {
  element.addEventListener(eventType, e => {
    let el = e.target;
    while (!el.matches(selector)) {
      if (element === el) {
        el = null;
        break;
      }
      el = el.parentNode;
    }
    el && fn(el, e);
  });
  return element;
}
on(ul, 'click', 'li', fn);
```

## 手写可拖拽的 DIV

```js
var dragging = false;
var position = null;

box.addEventListener('mousedown', function (e) {
  dragging = true;
  position = [e.clientX, e.clientY];
});

document.addEventListener('mousemove', function (e) {
  if (dragging === false) return;
  const x = e.clientX;
  const y = e.clientY;
  const detalX = x - position[0];
  const detalY = y - position[1];
  const left = parseInt(box.style.left || 0);
  const top = parseInt(box.style.top || 0);
  box.style.left = left + detalX + 'px';
  box.style.top = top + detalY + 'px';
  position = [x, y];
});
document.addEventListener('mouseup', function (e) {
  dragging = false;
});
```

```css
#box {
  width: 100px;
  height: 100px;
  border: 2px solid blue;
  position: absolute;
}
```

## HTTP 缓存

- 缓存
  - Cache-Control:max-age=3600
  - Etag:XXX
- 内容协商
  - If-None-Match:XXX
  - status: 304 or 200

## HTTPS

HTTPS = HTTP + SSL/TLS

- 机密性：通过混合加密，保证了信息的机密性。
  - 对称加密：加密内容
  - 非对称加密：加密公钥
- 完整性：摘要算法用来实现完整性。（哈希函数生产指纹）
- 身份认证：将服务器公钥放在数字证书中，解决了冒充的风险。

## HTTP 和 HTTPS 的区别

1. HTTP 是明文传输的，不安全；HTTPS 是加密传输的，非常安全。
2. HTTP 使用 80 端口；HTTPS 使用 443 端口。
3. HTTP 较快；HTTPS 较慢。
4. HTTP 证书免费；HTTPS 证书需要申请，一般需要付费。
