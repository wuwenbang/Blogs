# HTML

## 1 HTML 语义化

- 概念：语义化标签是一种写 HTML 标签的方法论。
- 优点：1.适合搜索引擎。2.适合人类阅读，利于团队维护

## 2 HTML 新标签

- 文章相关：header main footer main article
- 多媒体相关： video audio svg canvas

# CSS

## 1 BFC

- 概念：块级格式化上下文
- 描述：具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。
- 触发条件：
  - 浮动元素 float
  - 绝对定位元素 position absolute fixed
  - 行内块元素 inline block
  - overflow != visible 的块元素
  - 弹性元素 flex
- 解决问题：
  - 清除浮动
  - 防止 margin 合并
  - 可以阻止元素被浮动元素覆盖

## 2 垂直居中

1. 设置行高 line-height 等于 height（适用于 inline inline-block 元素）
2. calc 动态计算（top: calc(50% - height/2) ）
3. 使用表格或者假装表格

```css
width: 150px;
height: 100px;
border: 1px solid #000;
display: table-cell;
vertical-align: middle;
```

4. transform

```css
position: relative;
top: 50%;
transform: translateY(-50%);
```

5. 绝对定位

```css
position: absolute;
top: 0;
right: 0;
bottom: 0;
left: 0;
margin: auto;
```

6. Flexbox

## 3 CSS 选择器优先级如何确定？

1. 选择器越具体，优先级越高。
2. 相同优先级，出现在后面的，覆盖前面的。
3. 属性后面加 !important 的优先级最高，但是要少用。

## 4 如何清除浮动

1. 给父元素添加 `.clearfix`

```css
.clearfix:after {
  content: '';
  display: block;
  clear: both;
}
```

2. 给父元素添加 `overflow:hidden;`

## 5 盒模型

1. border-box
   实际宽度 = width
2. content-box
   实际宽度 = width + padding + border

# JavaScript

## 1 JavaScript 数据类型

- number
- string
- boolean
- undefined
- null
- object
- symbol
- bigint

## 2 JavaScript 原型链

- `obj.__proto__ = Object.prototype`
- 更改原型
  1.  Object.create(f)
  2.  new f()
- 解决问题：在没有 class 的情况下实现继承
- 缺点：与 class 相比不支持私有熟悉

## 3 this 是什么？

- 概念：this 是 call 的第一个参数。（谁调用了 this ，this 就是什么）
  - `f1() == f1.call(undefined, 'hi')`
  - `a.b.f('hi') == f.call(a.b, 'hi')`

## 4 new 做了什么？

1. 创建临时对象
2. 绑定原型
3. 指定 this = 临时对象
4. 执行构筑函数
5. 返回临时对象

## 5 立即执行函数是什么？

- 概念：声明一个函数立即执行
- 作用：创建一个局部变量（ES5）

```js
!(function () {
  console.log('hello');
})();
```

## 6 闭包是什么？

- 概念：闭包是 JS 的一种语法特性。
- 公式：闭包 = 函数 + 自由变量（非全局变量和局部变量）
- 解决问题：
  - 避免污染全局环境
  - 提供对局部变量的间接访问
  - 防止变量被垃圾回收

## 7 实现一个类

prototype 实现

```js
function Dog(name) {
  this.name = name;
}
Dog.prototype.say = function () {
  console.log(`hello my name is ${this.name}`);
};
```

class 实现

```js
class Dog {
  constructor(name) {
    this.name = name;
  }
  say() {
    console.log(`hello my name is ${this.name}`);
  }
}
```

## 8 实现继承

ES5

```js
function Animal(legs) {
  this.legs = legs;
}
Animal.prototype.kind = 'animal';

function Dog(name) {
  Animal.call(this, 4);
  this.name = name;
}
Dog.prototype.__protp__ = Animal.prototype; // ban

var f = function () {};
f.prototype = Animal.prototype;
Dog.prototype = new f();
```

ES6

```js
class Animal {
  constructor(legs) {
    this.legs = legs;
  }
  run() {}
}
class Dog extends Animal {
  constructor(name) {
    super(4);
    this.name = name;
  }
  say() {}
}
```

## 函数节流和防抖

```js
// 函数节流
function throttle(fn, wait) {
  let timer = null;
  return (...args) => {
    // 冷却中返回
    if (timer) return;
    // 执行函数
    fn(...args);
    // 设置冷却时间
    timer = setTimeout(() => {
      timer = null;
    }, wait);
  };
}
```

```js
// 函数防抖
function debounce(fn, wait) {
  let timer = null;
  return (...args) => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeout(() => fn(...args), wait);
  };
}
```

## 发布订阅

```js
// 发布订阅
const eventHub = {
  map: {},
  on(name, fn) {
    // 入队
    eventHub.map[name] = eventHub.map[name] || [];
    eventHub.map[name].push(fn);
  },
  off(name, fn) {
    const list = eventHub.map[name];
    if (!list) return;
    const index = list.indexOf(fn);
    if (index < 0) return;
    list.splice(index, 1);
  },
  emit(name, data) {
    const list = eventHub.map[name];
    if (!list) return;
    list.map(f => f(data));
  },
};
const fn = () => console.log('hello');
eventHub.on('click', fn);
eventHub.emit('click');
eventHub.off('click', fn);
eventHub.emit('click');
```

## 手写 AJAX

```js
var request = new XMLHttpRequest();

request.open('GET', '/xxx');
request.onreadystatechange = () => {
  if (request.readyState === 4) {
    if (
      (request.status >= 200 && request.status < 300) ||
      request.status === 304
    ) {
        success()
    } else {
        failed()
    }
  }
};
request.onerror = () => {
  console.log('error');
};
request.send('{"name":"frank"}');
```

